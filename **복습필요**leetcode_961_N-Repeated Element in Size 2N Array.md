
# 풀이
- 그냥 정렬하거나 해쉬쓰면 되는 문제.
- 근데 discuss에 기발한 풀이법이 있길래 알아봄.
- A[i]를 A[i-1] 과 A[i-2]와 비교하여 같으면 A[i]를 반환한다.
- 루프를 다 돌때까지 위의 조건을 만족하는 경우가 없으면 A[0]를 반환한다.
```python3
class Solution:
    def repeatedNTimes(self, A: List[int]) -> int:
        for i in range(2, len(A)):
            if A[i] == A[i-1] or A[i] == A[i-2]:
                return A[i]
        
        return A[0]
```
- 왜 이게 될까?
- 2N 개중에 중복되는 N개는 모든 N개의 각 숫자의 위치가 서로 2칸이 넘을 수 없다. 왜냐면 배열에는 총 2N개의 자리만 있기 때문.
- 이렇게 생각해보자. N개의 숫자를 2N개의 자리에 1칸씩 뛰어서 할당했다고 해보자.
- ``[1, 5, 2, 5, 3, 5, 4, 5]`` 이런식으로
- 여기서 위의 알고리즘을 피하기 위해 3번째의 5와 5번째의 5사이에 두칸 뛰게 하기 위해 5번째 5를 6번째자리와 바꾼다고 해보자
- ``[1, 5, 2, 5, 3, 4, 5, 5]'' 이런식으로
- 이러면 2칸 넘게 뛴 5가 생기지만 반대로 7번째 5와 8번째 5는 바로 붙어있게 되어 위의 알고리즘에 다시 걸리게 된다.
- 즉 두개의 5가 서로 2칸 넘게 뛰어 있으면 다른 자리에서 5는 서로 더 가까워 지게 되는 것이다.
