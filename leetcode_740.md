- 처음에 생각해낸 솔루션은 다음과 같다.
- 먼저 각 숫자의 합을 구한다. 예를 들어 배열이 1,1,1,1 2,2,2,2,2 3,3,3,3,3 4,4,4 일 경우 4(1의 합) 10(2의 합), 15(3의 합), 12(4의 합)로 만드는 것이다.
- 그 다음 뒤에서 부터 큰 숫자를 취한다. 예를 들면 12부터 볼 경우 15와 비교한다. 15가 더 크므로 12는 버리고 15를 취한다. 즉 3을 선택하고 4는 버리는 것이다.
- 그러나 이렇게 하면 2는 고려하지 못하게 된다. 즉, 3을 택하는 것은 4뿐만 아니라 2도 버리는 것이기 때문에 이 부분도 고려해야 한다.
- 그럼 여기서 2까지 고려할 경우??? 이 때는 1도 고려해야 한다. 2를 취하기로 택하면 1은 버려야 하기 때문이다.
- 즉, 먼저 앞쪽부터 봐야 뒤 쪽을 풀 수 있다. 다시 말하면 i번째 숫자를 취할지 말지를 알려면 i-1까지의 solution을 알아야 하는 것이다. 
- 이게 dp에서 나타나는 패턴이다. i번째 solution을 알려면 그전의 solution을 먼저 알아야 하는 것이다.
- 밑의 코드에서 sums[i]는 i번째까지 봤을때의 solution이다.
```python3
class Solution:
    def deleteAndEarn(self, nums: List[int]) -> int:
        sums = [0]*10000
        
        for num in nums:
            sums[num-1] += num
        
        sums[1] = max(sums[0], sums[1])
        
        for i in range(2, len(sums)):
            sums[i] = max(sums[i-2]+sums[i], sums[i-1])
        
        return sums[-1]
```
